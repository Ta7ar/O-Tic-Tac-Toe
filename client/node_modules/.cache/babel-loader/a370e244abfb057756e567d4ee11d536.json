{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar eio = require('engine.io-client');\n\nvar Socket = require('./socket');\n\nvar Emitter = require('component-emitter');\n\nvar parser = require('socket.io-parser');\n\nvar on = require('./on');\n\nvar bind = require('component-bind');\n\nvar debug = require('debug')('socket.io-client:manager');\n\nvar indexOf = require('indexof');\n\nvar Backoff = require('backo2');\n/**\n * IE6+ hasOwnProperty\n */\n\n\nvar has = Object.prototype.hasOwnProperty;\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager(uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n\n  var _parser = opts.parser || parser;\n\n  this.encoder = new _parser.Encoder();\n  this.decoder = new _parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.generateId(nsp);\n    }\n  }\n};\n/**\n * generate `socket.id` for the given `nsp`\n *\n * @param {String} nsp\n * @return {String}\n * @api private\n */\n\n\nManager.prototype.generateId = function (nsp) {\n  return (nsp === '/' ? '' : nsp + '#') + this.engine.id;\n};\n/**\n * Mix in `Emitter`.\n */\n\n\nEmitter(Manager.prototype);\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\n\nManager.prototype.open = Manager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false; // emit `open`\n\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  }); // emit `connect_error`\n\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  }); // emit `connect_timeout`\n\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout); // set timer\n\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n    this.subs.push({\n      destroy: function destroy() {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n  return this;\n};\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\n\nManager.prototype.onopen = function () {\n  debug('open'); // clear old subs\n\n  this.cleanup(); // mark as open\n\n  this.readyState = 'open';\n  this.emit('open'); // add new subs\n\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n/**\n * Called with data.\n *\n * @api private\n */\n\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.generateId(nsp);\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting event is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting() {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n  this.close();\n};\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else {\n    // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n  var subsLength = this.subs.length;\n\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n  this.decoder.destroy();\n};\n/**\n * Close the current socket.\n *\n * @api private\n */\n\n\nManager.prototype.close = Manager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts); // check again for the case socket closed in above events\n\n      if (self.skipReconnect) return;\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n    this.subs.push({\n      destroy: function destroy() {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};","map":{"version":3,"sources":["C:/Users/Tatar/Documents/Full Stack Projects/O Tic-Tac-Toe - Copy/client/node_modules/socket.io-client/lib/manager.js"],"names":["eio","require","Socket","Emitter","parser","on","bind","debug","indexOf","Backoff","has","Object","prototype","hasOwnProperty","module","exports","Manager","uri","opts","undefined","path","nsps","subs","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","min","max","jitter","timeout","readyState","connecting","lastPing","encoding","packetBuffer","_parser","encoder","Encoder","decoder","Decoder","autoConnect","open","emitAll","emit","apply","arguments","nsp","call","updateSocketIds","id","generateId","engine","v","length","_reconnection","_reconnectionAttempts","_reconnectionDelay","setMin","_randomizationFactor","setJitter","_reconnectionDelayMax","setMax","_timeout","maybeReconnectOnOpen","reconnecting","attempts","reconnect","connect","fn","socket","self","skipReconnect","openSub","onopen","errorSub","data","cleanup","err","Error","timer","setTimeout","destroy","close","push","clearTimeout","onping","Date","onpong","ondata","add","ondecoded","packet","onerror","onConnecting","index","splice","query","type","encode","encodedPackets","i","write","options","processPacketQueue","pack","shift","subsLength","sub","disconnect","reset","onclose","reason","delay","duration","onreconnect","attempt"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar eio = require('engine.io-client');\nvar Socket = require('./socket');\nvar Emitter = require('component-emitter');\nvar parser = require('socket.io-parser');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:manager');\nvar indexOf = require('indexof');\nvar Backoff = require('backo2');\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  var _parser = opts.parser || parser;\n  this.encoder = new _parser.Encoder();\n  this.decoder = new _parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.generateId(nsp);\n    }\n  }\n};\n\n/**\n * generate `socket.id` for the given `nsp`\n *\n * @param {String} nsp\n * @return {String}\n * @api private\n */\n\nManager.prototype.generateId = function (nsp) {\n  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.generateId(nsp);\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting event is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n"]},"metadata":{},"sourceType":"script"}